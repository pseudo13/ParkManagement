{"version":3,"sources":["services/parkService.ts","components/ParkingPlaceComponent.tsx","components/ParkRowComponent.tsx","components/ParkLevelComponent.tsx","models/ParkModels.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["subject","Subject","parkService","place","next","asObservable","ParkingPlaceComponent","props","subscriptions","state","occupied","this","subscribe","param","level","columnIndex","rowIndex","setState","unsubscribe","className","join","React","Component","ParkRowComponent","parkingRow","columns","map","column","i","custom-park-place","key","ParkLevelComponent","parkLevel","Fragment","parkingRows","custom-park-row","ParkingPlace","l","r","c","o","ParkingRow","Array","fill","x","ParkingLevel","rows","push","App","intervallId","parkingLevels","_","useState","displayMessage","setDisplayMessage","useEffect","window","addEventListener","handleIframeTask","e","data","simulateCars","stopSimulating","setInterval","Math","random","carEnter","carLeaves","parkState","clearInterval","length","freeColumn","rr","flat","find","pl","pr","pc","filter","allColumns","occupiedColumns","console","log","randomPlace","floor","error","onClick","custom-park-level","toString","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.05f50622.chunk.js","sourcesContent":["import { ParkingPlace } from \"../models/ParkModels\";\r\nimport { Subject } from \"rxjs\";\r\n\r\nconst subject = new Subject<{ place: ParkingPlace }>();\r\n\r\nexport const parkService = {\r\n  toggleParkPlaceState: (place: ParkingPlace) => subject.next({ place }),\r\n  getParkPlaceState: () => subject.asObservable()\r\n};\r\n","import { ParkingPlace } from \"../models/ParkModels\";\r\nimport React from \"react\";\r\nimport { parkService } from \"../services/parkService\";\r\n\r\ntype ParkingPlaceProps = {\r\n  place: ParkingPlace;\r\n  key: string;\r\n};\r\n\r\ntype OccopiedState = {\r\n  occupied: boolean;\r\n};\r\n\r\nexport class ParkingPlaceComponent extends React.Component<\r\n  ParkingPlaceProps,\r\n  OccopiedState\r\n> {\r\n  place: ParkingPlace;\r\n\r\n  subscriptions: any;\r\n  constructor(props: ParkingPlaceProps) {\r\n    super(props);\r\n    this.place = this.props.place;\r\n    this.state = {\r\n      occupied: false\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    this.subscriptions = parkService.getParkPlaceState().subscribe(param => {\r\n      const { place } = param;\r\n\r\n      if (\r\n        this.place.level == place.level &&\r\n        this.place.columnIndex == place.columnIndex &&\r\n        this.place.rowIndex == place.rowIndex\r\n      ) {\r\n        this.setState({ occupied: place.occupied });\r\n      }\r\n    });\r\n  }\r\n\r\n  componentWillMount() {\r\n    if (this.subscriptions) {\r\n      this.subscriptions.unsubscribe();\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <span\r\n        className={[\r\n          \"park-place\",\r\n          this.state.occupied ? \"occupied\" : \"open\"\r\n        ].join(\" \")}\r\n      >\r\n        {this.place.rowIndex + \"_\" + this.place.columnIndex}\r\n      </span>\r\n    );\r\n  }\r\n}\r\n","import { ParkingPlaceComponent } from \"./ParkingPlaceComponent\";\r\nimport { Fragment } from \"react\";\r\nimport React from \"react\";\r\nimport { ParkingRow } from \"../models/ParkModels\";\r\n\r\nexport const ParkRowComponent = (props: {\r\n  parkingRow: ParkingRow;\r\n  key: string;\r\n}) => {\r\n  const { parkingRow } = props;\r\n  return (\r\n    <Fragment>\r\n      {parkingRow.columns.map((column, i) => {\r\n        return (\r\n          <ParkingPlaceComponent\r\n            custom-park-place={column.level + \"_\" + column.rowIndex + \"_\" + i}\r\n            place={column}\r\n            key={column.level + \"_\" + column.rowIndex + \"_\" + i}\r\n          ></ParkingPlaceComponent>\r\n        );\r\n      })}\r\n    </Fragment>\r\n  );\r\n};\r\n","import React, { Fragment } from \"react\";\r\nimport { ParkRowComponent } from \"./ParkRowComponent\";\r\nimport { ParkingLevel } from \"../models/ParkModels\";\r\n\r\nexport const ParkLevelComponent = (props: {\r\n  parkLevel: ParkingLevel;\r\n  key: string;\r\n}) => {\r\n  const { parkLevel } = props;\r\n  return (\r\n    <React.Fragment>\r\n      <strong>Park number : {parkLevel.level}</strong>\r\n      {parkLevel.parkingRows.map((parkingRow, i) => {\r\n        return (\r\n          <div>\r\n            <ParkRowComponent\r\n              custom-park-row={parkingRow.level + \"_\" + i}\r\n              key={parkingRow.level + \"_\" + i}\r\n              parkingRow={parkingRow}\r\n            ></ParkRowComponent>\r\n          </div>\r\n        );\r\n      })}\r\n    </React.Fragment>\r\n  );\r\n};\r\n","export class ParkingPlace {\r\n  level: number;\r\n  columnIndex: number;\r\n  rowIndex: number;\r\n  occupied: boolean = false;\r\n\r\n  constructor(l: number, r: number, c: number, o = false) {\r\n    this.level = l;\r\n    this.rowIndex = r;\r\n    this.columnIndex = c;\r\n    this.occupied = o;\r\n  }\r\n}\r\n\r\nexport class ParkingRow {\r\n  constructor(level: number, rowIndex: number) {\r\n    this.level = level;\r\n    this.columns = Array(9)\r\n      .fill({})\r\n      .map((x, i) => new ParkingPlace(this.level, rowIndex, i));\r\n  }\r\n  level: number;\r\n  columns: ParkingPlace[];\r\n}\r\n\r\nexport class ParkingLevel {\r\n  parkingRows: ParkingRow[] = [];\r\n  level: number;\r\n  constructor(level: number, rows: number) {\r\n    this.level = level;\r\n    for (let i = 0; i < rows; i++) {\r\n      this.parkingRows.push(new ParkingRow(this.level, i));\r\n    }\r\n  }\r\n}\r\n","import React, { useState, useEffect } from \"react\";\nimport { ParkLevelComponent } from \"./components/ParkLevelComponent\";\nimport { ParkingLevel, ParkingPlace } from \"./models/ParkModels\";\nimport { parkService } from \"./services/parkService\";\n\nfunction App() {\n  const parkingLevels: ParkingLevel[] = Array(...Array(3)).map(\n    (_, i) => new ParkingLevel(i, 4)\n  );\n\n  let intervallId: number;\n\n  const [displayMessage, setDisplayMessage] = useState({\n    displayMessage: \"Park is free. Please come in.\"\n  });\n\n  useEffect(() => {\n    window.addEventListener(\"message\", handleIframeTask);\n  }, []);\n\n  const handleIframeTask = (e: any) => {\n    if (e.data === \"START_SIMULATING\") {\n      simulateCars();\n    } else if (e.data == \"STOP_SIMULATING\") {\n      stopSimulating();\n    }\n  };\n\n  const simulateCars = () => {\n    intervallId = window.setInterval(() => {\n      let rand = Math.random() * 10;\n      if (rand <= 7) {\n        carEnter();\n      } else {\n        carLeaves();\n      }\n    }, 500);\n  };\n\n  const parkState: any = {};\n\n  const stopSimulating = () => {\n    clearInterval(intervallId);\n  };\n\n  const carEnter = () => {\n    for (let i = 0; i < parkingLevels.length; i++) {\n      var levelColumns = (parkState[i] = parkingLevels[i].parkingRows\n        .map(r => r.columns.map(rr => rr))\n        .flat());\n      let freeColumn: ParkingPlace | undefined = levelColumns.find(\n        c => !c.occupied\n      );\n      if (freeColumn) {\n        freeColumn.occupied = true;\n        parkService.toggleParkPlaceState(freeColumn);\n\n        let allColumns: ParkingPlace[] = parkingLevels\n          .map(pl => pl.parkingRows.map(pr => pr.columns.map(pc => pc)))\n          .flat()\n          .flat();\n        let freeColumnsAfter = allColumns.filter(c => !c.occupied);\n        //console.log(freeColumn);\n        if (freeColumnsAfter.length == 0) {\n          //alert(\"Park is full. Please wait.\");\n          setDisplayMessage({ displayMessage: \"Park is full. Please wait.\" });\n        }\n        break;\n      }\n    }\n    //(parkState);\n  };\n\n  const carLeaves = () => {\n    let allColumns: ParkingPlace[] = parkingLevels\n      .map(pl => pl.parkingRows.map(pr => pr.columns.map(pc => pc)))\n      .flat()\n      .flat();\n    let occupiedColumns = allColumns.filter(c => c.occupied);\n    console.log(allColumns, occupiedColumns);\n    try {\n      let rand = Math.floor(Math.random() * occupiedColumns.length);\n      let randomPlace = occupiedColumns[rand];\n      randomPlace.occupied = false;\n      parkService.toggleParkPlaceState(randomPlace);\n      setDisplayMessage({ displayMessage: \"Park is free. Please come in.\" });\n    } catch (error) {}\n  };\n\n  return (\n    <div className=\"App\">\n      <button onClick={simulateCars}>Start simulating cars</button>\n      <button onClick={stopSimulating}>Stop simulationg cars</button>\n      <h3>{displayMessage.displayMessage}</h3>\n      <hr />\n      {parkingLevels.map((l, i) => {\n        return (\n          <div className=\"park-level\" key={i}>\n            <ParkLevelComponent\n              custom-park-level={i}\n              parkLevel={l}\n              key={i.toString()}\n            ></ParkLevelComponent>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      \"No internet connection found. App is running in offline mode.\";\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}